"use strict"

((root, modulename, factory) ->
  if typeof define === 'function' and define.amd
    define ->
      root.wire = root.wire or {}
      root.wire[modulename] = factory()
  else
    root.wire = root.wire or {}
    root.wire[modulename] = factory())(this, 'View', ->

  eventSplitterRe = /\s+/

  specialAttributes = ['events']

  class View

    tag: 'div'

    (options) ->
      for key, value in options
        if specialAttributes.indexOf(key) is -1
            this[key] = value

      if not this.el
        this.el = $(document.createElement(this.tag))

      events = options?.events or {}
      if this.events
        _.extend(events, this.events or {})
      if events
        this.configureEvents(events)

      this.events = events

    # Configure events of a view.
    #
    # @param {Object} events
    #   The event declaration table, keys can be of form
    #
    #     a '<eventname> <dom selector>'
    #       in that case there will be event handler attached to event
    #       <eventname> on DOM element selected by <dom selector>
    #
    #     b 'eventname this.<path>'
    #       in that case there will be event handler attached to event
    #       <eventname> on this.<path> attribute of a view
    #
    configureEvents: (events) ->
      for k, v in events
        if not typeof v is 'function'
          if v[0..6] is 'event '
            let
              v = -> this.trigger(v[7..])
          else
            let
              v = -> this[v].apply(this, arguments)
        [ev, path] = k.split(eventSplitterRe)
        if path is ''
          this.el.bind(ev, v)
        else if path[0..5] is 'this.'
          wire.path(this, path[6..]).on(ev, v)
        else
          this.el.delegate(path, ev, v)

    # Scoped DOM selector
    #
    # @param {String} selector
    $: (selector) ->
      $(selector, this.el)

    release: ->
      this.el.remove()
      this.off()
      # TODO what about DOM events?

  _.extend(View.prototype, wire.Event)

  View
)
