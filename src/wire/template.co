#
# Copyright 2009-2011 Mozilla Foundation and contributors
# Licensed under the New BSD license. See LICENSE.txt or:
# http://opensource.org/licenses/BSD-3-Clause
#

define (require) ->

  _parseExpr = require('wire/templateexpression').parse

  #
  # Cached regex used to find ${...} sections in some text.
  # Performance note: This regex uses ( and ) to capture the 'script' for
  # further processing. Not all of the uses of this regex use this feature so
  # if use of the capturing group is a performance drain then we should split
  # this regex in two.
  #
  _templateRegion = /\$\{([^}]*)\}/g

  #
  # Cached regex used to split a string using the unicode chars F001 and F002.
  # See Templater._processTextNode() for details.
  #
  _splitSpecial = /\uF001|\uF002/

  #
  # Cached regex used to detect if a script is capable of being interpreted
  # using Template._property() or if we need to use Template.envEval()
  #
  _isPropertyScript = /^[_a-zA-Z0-9.]*$/

  parseExpr = (expr) ->
    if _isPropertyScript.test(expr)
      {type: 'expression', expr: expr, refs: [expr]}
    else
      _parseExpr(expr)

  #
  # Begin a new templating process.
  # @param node A DOM element or string referring to an element's id
  # @param data Data to use in filling out the template
  # @param options Options to customize the template processing. One of:
  # - allowEval: boolean (default false) Basic template interpolations are
  #   either property paths (e.g. ${a.b.c.d}), or if allowEval=true then we
  #   allow arbitrary JavaScript
  # - stack: string or array of strings (default empty array) The template
  #   engine maintains a stack of tasks to help debug where it is. This allows
  #   this stack to be prefixed with a template name
  # - blankNullUndefined: By default DOMTemplate exports null and undefined
  #   values using the strings 'null' and 'undefined', which can be helpful for
  #   debugging, but can introduce unnecessary extra logic in a template to
  #   convert null/undefined to ''. By setting blankNullUndefined:true, this
  #   conversion is handled by DOMTemplate
  #
  template = (node, data, options) ->
    template = new Templater(options || {})
    template.processNode(node, data)
    template

  #
  # Construct a Templater object. Use template() in preference to this ctor.
  # @deprecated Use template(node, data, options);
  #
  class Templater

    (options) ->
      if options == null
        options = { allowEval: true }
      this.options = options
      if options.stack && Array.isArray(options.stack)
        this.stack = options.stack
      else if typeof options.stack === 'string'
        this.stack = [options.stack]
      else
        this.stack = []
      this.nodes = []
      this.exprs = options.exprs || {}

    #
    # Recursive function to walk the tree processing the attributes as it goes.
    # @param node the node to process. If you pass a string in instead of a DOM
    # element, it is assumed to be an id for use with document.getElementById()
    # @param data the data to use for node processing.
    #
    processNode: (node, data) ->
      if typeof node === 'string'
        node = document.getElementById(node)
      if data == null
        data = {}
      this.stack.push(node.nodeName + (node.id ? '#' + node.id : ''))
      pushedNode = false
      try
        # Process attributes
        if node.attributes && node.attributes.length
          # We need to handle 'foreach' and 'if' first because they might stop
          # some types of processing from happening, and foreach must come first
          # because it defines new data on which 'if' might depend.
          if node.hasAttribute('foreach')
            this._processForEach(node, data)
            return
          if node.hasAttribute('if')
            if !this._processIf(node, data)
              return
            # Only make the node available once we know it's not going away
          this.nodes.push(data.__element)
          data.__element = node
          pushedNode = true
          # It's good to clean up the attributes when we've processed them,
          # but if we do it straight away, we mess up the array index
          attrs = Array.prototype.slice.call(node.attributes)
          for attr of attrs
            value = attr.value
            name = attr.name
            this.stack.push(name)
            try
              if name === 'save'
                # Save attributes are a setter using the node
                value = this._stripBraces(value)
                this._property(value, data, node)
                node.removeAttribute('save')
              else if name.substring(0, 2) === 'on'
                # If this attribute value contains only an expression
                if value.substring(0, 1) === '${' && value.slice(-1) === '}' && value.indexOf('${', 2) === -1
                  value = this._stripBraces(value)
                  func = this._property(expr.value, data)
                  if typeof func === 'function'
                    node.removeAttribute(name)
                    capture = node.hasAttribute('capture' + name.substring(2))
                    node.addEventListener(name.substring(2), func, capture)
                    if capture
                      node.removeAttribute('capture' + name.substring(2))
                  else
                    # Attribute value is not a function - use as a DOM-L0 string
                    attr.value = func
                else
                  # Attribute value is not a single expression use as DOM-L0
                  attr.value = this._processString(value, data)
              else
                # Replace references in all other attributes
                newValue = this._processString(value, data)
                # Remove '_' prefix of attribute names so the DOM won't try
                # to use them before we've processed the template
                if name.charAt(0) === '_'
                  node.removeAttribute(name)
                  node.setAttribute(name.substring(1), newValue)
                else if value !== newValue
                  attr.value = newValue
            finally
              this.stack.pop()

        # Loop through our children calling processNode. First clone them, so the
        # set of nodes that we visit will be unaffected by additions or removals.
        childNodes = Array.prototype.slice.call(node.childNodes)
        for childNode of childNodes
          this.processNode(childNode, data)

        # Node.TEXT_NODE
        if node.nodeType === 3
          this._processTextNode(node, data)
      finally
        if pushedNode
          data.__element = this.nodes.pop()
        this.stack.pop()

    #
    # Handle attribute values where the output can only be a string
    #
    _processString: (value, data) ->
      value.replace _templateRegion, (path) ~>
        expr = parseExpr(path.slice(2, -1))
        insert = this.envEval(expr.expr, data, value)
        if this.options.blankNullUndefined && insert == null
          insert = ''
        insert

    #
    # Handle <x if="${...}">
    # @param node An element with an 'if' attribute
    # @param data The data to use with envEval()
    # @returns true if processing should continue, false otherwise
    #
    _processIf: (node, data) ->
      this.stack.push('if')
      try
        originalValue = node.getAttribute('if')
        value = this._stripBraces(originalValue)
        expr = parseExpr(value)
        recurse = true
        try
          reply = this.envEval(expr.expr, data, originalValue)
          recurse = !!reply
        catch ex
          this._handleError("Error with '#{expr.expr}'", ex)
          recurse = false
        if !recurse
          node.parentNode.removeChild(node)
        else
          if node.nodeName.toLowerCase() === 'block'
            curNode = node
            for childNode of node.childNodes
              clone = childNode.cloneNode(true)
              node.parentNode.insertBefore(clone, curNode.nextSibling)
              curNode = clone
              this.processNode(clone, data)
            node.parentNode.removeChild(node)
          else
            node.removeAttribute('if')
        recurse
      finally
        this.stack.pop()

    #
    # Handle <x foreach="param in ${array}"> and the special case of
    # <block foreach="param in ${array}">.
    # This function is responsible for extracting what it has to do from the
    # attributes, and getting the data to work on (including resolving promises
    # in getting the array). It delegates to _processForEachLoop to actually
    # unroll the data.
    # @param node An element with a 'foreach' attribute
    # @param data The data to use with envEval()
    #
    _processForEach: (node, data) ->
      this.stack.push('foreach')
      try
        originalValue = node.getAttribute('foreach')
        originalValue = this._stripBraces(originalValue)
        expr = parseExpr(originalValue)
        paramName = if expr.type === 'iteration' then expr.loopvar else 'item'
        node.removeAttribute('foreach')
        try
          evaled = this.envEval(expr.expr, data, originalValue)
          this._handleAsync evaled, node, (reply, siblingNode) ~>
            this._processForEachLoop(reply, node, siblingNode, data, paramName)
          node.parentNode.removeChild(node)
        catch ex
          this._handleError("Error with '#{expr.expr}'", ex)
      finally
        this.stack.pop()

    #
    # Called by _processForEach to handle looping over the data in a foreach loop.
    # This works with both arrays and objects.
    # Calls _processForEachMember() for each member of 'set'
    # @param set The object containing the data to loop over
    # @param template The node to copy for each set member
    # @param sibling The sibling node to which we add things
    # @param data the data to use for node processing
    # @param paramName foreach loops have a name for the parameter currently being
    # processed. The default is 'param'. e.g. <block foreach="param in ${x}">...
    #
    _processForEachLoop: (set, template, sibling, data, paramName) ->
      if Array.isArray(set)
        set.forEach (member, i) ~>
          this._processForEachMember(member, template, sibling, data, paramName, '' + i)
      else
        for member in set
          if set.hasOwnProperty(member)
            this._processForEachMember(member, template, sibling, data, paramName, member)

    #
    # Called by _processForEachLoop() to resolve any promises in the array (the
    # array itself can also be a promise, but that is resolved by
    # _processForEach()). Handle <LOOP> elements (which are taken out of the DOM),
    # clone the template, and pass the processing on to processNode().
    # @param member The data item to use in templating
    # @param template The node to copy for each set member
    # @param siblingNode The parent node to which we add things
    # @param data the data to use for node processing
    # @param paramName The name given to 'member' by the foreach attribute
    # @param frame A name to push on the stack for debugging
    #
    _processForEachMember: (member, template, siblingNode, data, paramName, frame) ->
      this.stack.push(frame)
      try
        this._handleAsync member, siblingNode, (reply, node) ~>
          data[paramName] = reply
          if template.nodeName.toLowerCase() === 'block'
            for childNode of template.childNodes
              clone = childNode.cloneNode(true)
              node.parentNode.insertBefore(clone, node)
              this.processNode(clone, data)
          else
            clone = template.cloneNode(true)
            clone.removeAttribute('foreach')
            node.parentNode.insertBefore(clone, node)
            this.processNode(clone, data)
          delete data[paramName]
      finally
        this.stack.pop()

    #
    # Take a text node and replace it with another text node with the ${...}
    # sections parsed out. We replace the node by altering node.parentNode but
    # we could probably use a DOM Text API to achieve the same thing.
    # @param node The Text node to work on
    # @param data The data to use in calls to envEval()
    #
    _processTextNode: (node, data) ->
      # Replace references in other attributes
      value = node.data
      # We can't use the string.replace() with function trick (see generic
      # attribute processing in processNode()) because we need to support
      # functions that return DOM nodes, so we can't have the conversion to a
      # string.
      # Instead we process the string as an array of parts. In order to split
      # the string up, we first replace '${' with '\uF001$' and '}' with '\uF002'
      # We can then split using \uF001 or \uF002 to get an array of strings
      # where scripts are prefixed with $.
      # \uF001 and \uF002 are just unicode chars reserved for private use.
      value = value.replace(_templateRegion, '\uF001$$$1\uF002')
      parts = value.split(_splitSpecial)
      if parts.length > 1
        parts.forEach (part) ~>
          if part === null || part === undefined || part === ''
            return
          if part.charAt(0) === '$'
              expr = parseExpr(part.slice(1))
              part = this.envEval(expr.expr, data, node.data)
          this._handleAsync part, node, (reply, siblingNode) ~>
            doc = siblingNode.ownerDocument
            if reply == null
              reply = if this.options.blankNullUndefined then '' else '' + reply
            if typeof reply.cloneNode === 'function'
              # i.e. if (reply instanceof Element) { ...
              reply = this._maybeImportNode(reply, doc)
              siblingNode.parentNode.insertBefore(reply, siblingNode)
            else if typeof reply.item === 'function' && reply.length
              # NodeLists can be live, in which case _maybeImportNode can
              # remove them from the document, and thus the NodeList, which in
              # turn breaks iteration. So first we clone the list
              list = Array.prototype.slice.call(reply, 0)
              list.forEach (child) ~>
                imported = this._maybeImportNode(child, doc)
                siblingNode.parentNode.insertBefore(imported, siblingNode)
            else
              # if thing isn't a DOM element then wrap its string value in one
              reply = doc.createTextNode(reply.toString())
              siblingNode.parentNode.insertBefore(reply, siblingNode)
        node.parentNode.removeChild(node)

    #
    # Return node or a import of node, if it's not in the given document
    # @param node The node that we want to be properly owned
    # @param doc The document that the given node should belong to
    # @return A node that belongs to the given document
    #
    _maybeImportNode: (node, doc) ->
      return if node.ownerDocument === doc then node else doc.importNode(node, true)

    #
    # A function to handle the fact that some nodes can be promises, so we check
    # and resolve if needed using a marker node to keep our place before calling
    # an inserter function.
    # @param thing The object which could be real data or a promise of real data
    # we use it directly if it's not a promise, or resolve it if it is.
    # @param siblingNode The element before which we insert new elements.
    # @param inserter The function to to the insertion. If thing is not a promise
    # then _handleAsync() is just 'inserter(thing, siblingNode)'
    #
    `prototype._handleAsync = function(thing, siblingNode, inserter) {
      if (thing != null && typeof thing.then === 'function') {
        // Placeholder element to be replaced once we have the real data
        var tempNode = siblingNode.ownerDocument.createElement('span');
        siblingNode.parentNode.insertBefore(tempNode, siblingNode);
        thing.then(function(delayed) {
          inserter(delayed, tempNode);
          tempNode.parentNode.removeChild(tempNode);
        }.bind(this));
      }
      else {
        inserter(thing, siblingNode);
      }
    };`

    #
    # Warn of string does not begin '${' and end '}'
    # @param str the string to check.
    # @return The string stripped of ${ and }, or untouched if it does not match
    #
    _stripBraces: (str) ->
      if !str.match(_templateRegion)
        str
      else
        str.slice(2, -1)

    #
    # Combined getter and setter that works with a path through some data set.
    # For example:
    # <ul>
    # <li>_property('a.b', { a: { b: 99 }}); // returns 99
    # <li>_property('a', { a: { b: 99 }}); // returns { b: 99 }
    # <li>_property('a', { a: { b: 99 }}, 42); // returns 99 and alters the
    # input data to be { a: { b: 42 }}
    # </ul>
    # @param path An array of strings indicating the path through the data, or
    # a string to be cut into an array using <tt>split('.')</tt>
    # @param data the data to use for node processing
    # @param newValue (optional) If defined, this value will replace the
    # original value for the data at the path specified.
    # @return The value pointed to by <tt>path</tt> before any
    # <tt>newValue</tt> is applied.
    #
    _property: (path, data, newValue) ->
      try
        if typeof path === 'string'
          path = path.split('.')
        value = data[path[0]]
        if path.length === 1
          if newValue !== undefined
            data[path[0]] = newValue
          if typeof value === 'function'
            return value.bind(data)
          return value
        if !value
          this._handleError("'#{path[0]}' is undefined")
          return null
        this._property(path.slice(1), value, newValue)
      catch ex
        this._handleError("Path error with '#{path}'", ex)
        "${#{path}}"

    #
    # Like eval, but that creates a context of the variables in <tt>env</tt> in
    # which the script is evaluated.
    # WARNING: This script uses 'with' which is generally regarded to be evil.
    # The alternative is to create a Function at runtime that takes X parameters
    # according to the X keys in the env object, and then call that function using
    # the values in the env object. This is likely to be slow, but workable.
    # @param script The string to be evaluated.
    # @param data The environment in which to eval the script.
    # @param frame Optional debugging string in case of failure.
    # @return The return value of the script, or the error message if the script
    # execution failed.
    #
    envEval: (script, data, frame) ->
      try
        this.stack.push(frame.replace(/\s+/g, ' '))
        if _isPropertyScript.test(script)
          return this._property(script, data)
        else
          if !this.options.allowEval
            this._handleError("allowEval is not set, however '#{script}'
                              can not be resolved using a simple property path.")
            return "${#{script}}"
          result = null
          `with (data) {
            result = eval(script);
          }`
          result
      catch ex
        this._handleError("Template error evaluating '#{script}'", ex)
        return "${#{script}}"
      finally
        this.stack.pop()

    #
    # A generic way of reporting errors, for easy overloading in different
    # environments.
    # @param message the error message to report.
    # @param ex optional associated exception.
    #
    _handleError: (message, ex) ->
      this._logError("#{message} (In: #{this.stack.join(' > ')})")
      if ex
        this._logError(ex)

    #
    # A generic way of reporting errors, for easy overloading in different
    # environments.
    # @param message the error message to report.
    #
    _logError: (message) ->
      console.log(message)

  {template}
