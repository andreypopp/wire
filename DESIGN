# Wire -- application development toolkit

Common principles are:

  * Library, not a framework

    Doesn't dictate how to structure application.

  * Non-intrusiveness

    You can use any part of the library separately and mix it with other
    libraries.

  * Doesn't support old browsers

    WebKit and Gecko based browsers are preferable over latest IEs, older IEs
    are out of consideration at all.

  * Tests, stylechecks

    Code should be tested and checked with jslint/jshint.

Open questions:

  * Should we use AMD or any other module system? maybe we should provide
    separate AMD and non-AMD builds.

## Planned features

This is not complete or final list of planned or desires features.

### wire.event

An event system (not a DOM one), implemented as a mix-in. See Backbone.Event as
an example implementation. Possibly we should just use it.

### wire.track

Track changes on objects and arrays. Possible APIs and impls skecthes:

  1 Implicit setters

    Install implicit setter on attribute for objects and fire an event via
    wire.event on value change

      var o = {a: 1, b: 2}
      wire.track.track(o.a) // installs implicit setter
      o.a = 2 // fires changes

    Clean API but lacks transactional semantics. See Simpli5 as an example
    implementation.

  2 "Register-modify-check"

      var o = {a: 1, b: 2}
      wire.track.track(o, ['a', 'b']) // registers object with tracking system
      o.a = 2
      wire.track.check(o) // fires 'change:a'

    Transactional semantics make such approach a useful one in some cases.

  3 Explicit setters

      o.set("a", 1) // fires event

    Backbone.Model does this. Very Java-like and verbose.

I would better implement 1 or 2 or both of them.

### wire.binding

Unidirectional or bidirectional bindings on top of wire.track.

### wire.template

Data-binding aware templating. The API is:

    var template = wire.template.compile(templateString);
    var ctx = {...};
    template.bind(ctx);

#### Templates

There're two types of templates available, one for objects:

    <w:template for="model">
      ...
    </w:template>

and one for arrays:

    <w:template foreach="model">
      ...
    </w:template>

Templates behave like this:

  * Templates can be nested.

  * If no 'for' or 'foreach' attribute is defined then template will be bound to
    root context -- 'ctx'.

#### Bindings

Inside template there could defined any number of bindings:

    <w:template for="model">
      {title}
    </w:template>

would be compiled into:

    ctx.model.title

This also works on attribute level:

    <div class="box box-{type}">
      ...
    </div>

#### Conditionals

Conditionals can be of form:

    <w:if cond="expression">

    </w:if>

or:

    <div w:if="expression">

    </div>

#### Expression language

Inside {...} you can use basic expression language:

  * Operators \*-/, brackets

    {trackNumber * 10 - 100}

  * Function calls

    {formatNumber(trackNumber)}

  * $ always points to root object so you can reference it like this

    {$.formatNumber(trackNumber)}

  * to get reference to parent, use ..

    {..formatNumber(trackNumber)}

  * . references current object

    {.attribute}

  * Conditionals

    {if (trackNumber > 100) "yes" else "no"}

    'else' clause is optional

    {if (trackNumber > 100) "yes"}

### wire.view.View

  * Backbone.View as a prototype, add shortcuts for translating DOM and
    this.<elem> events into own events, e.g.

        events:
          'click .myClass': 'event click'
          'newdata this.model': 'event newdata'

  * optionally structure views into tree and treat it as shadow DOM, e.g.
    selectors and traversing and so on

### wire.view.BoundView

View which owns model and uses wire.template for binding DOM and model.

Built on top of wire.view.View and wire.template, example API:

    class View

      // inline templates as well as selectors in DOM are allowed
      template: """
        <div>
          <span>{title}</span>
          <img src={image.href}/>
          <a class="inLibraryToggle">
            {if inLibrary}In library{else}Not in library{end}
          </a>
        </div>
      """

      events:
        "click .inLibraryToggle": "onInLibraryToggle"

      onInLibraryToggle: () ->
        // fires 'change:inLibrary' and thus updates the view
        this.model.inLibrary = !this.model.inLibrary

    o = {
      title: "Some title",
      image: {href: "http://..."},
      inLibrary: false
      }

    w = new Widget(o)
    document.root.append(w.render())

    // fires 'change:title' event on `o` object and thus updating view
    // only renders dependent parts of it
    o.title = "Another title"

Notes:

  * Maybe it should be possible to specify event handlers inline in templates,
    e.g. onclick="onInLibraryToggle" and so on.

### wire.persistence

See how meteor does it, but try to make it more storage agnostic, maybe just
some conventions like Backbone.Model does. Batman.js also has persistence
mechanism which seems to be a close thing to what we want.

## References

  * Backbone

  * spine.js

  * Google Model-Driven-Views (mdv for short)

  * Simpli5
